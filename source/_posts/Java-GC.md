title: 理解 Java 垃圾回收机制
date: 2016-02-15 21:55:40
tags: 
- Java
- GC
comments: true
categories: Java
---

> 原文 http://www.cubrid.org/blog/dev-platform/understanding-java-garbage-collection/
> 作者 Sangmin Lee NHN公司，性能设计实验室高级工程师

理解java垃圾回收机制有什么好处呢？作为一个软件工程师，满足自己的好奇心将是一个很好的理由，不过更重要的是，理解GC的工作机制可以帮助你写出更好的Java程序。

这是我个人的主观观点，但我相信一个人精通了GC，往往会是一个更好的Java程序员。如果你对GC感兴趣，那就意味着你有一定大规模应用开发的经验。如果你已经仔细考虑选择合适的GC算法，这意味着你完全理解你开发的应用程序的功能。当然，这可能不是一个优秀开发者的共同标准。然而，很少有人反对我说的：理解GC是成为一个伟大的Java开发人员的要求。

这是“[成为一个Java GC专家](http://www.cubrid.org/blog/tags/Garbage%20Collection/)”系列文章的第一部分。这次我将讲述GC简介，而在下一篇文章中，我将讨论分析GC状态和来自[NHN](http://www.cubrid.org/blog/tags/NHN/)的GC调优的例子。

本文的目的是用简单的方式向你介绍GC。我希望这篇文章被证明是非常有帮助的。事实上，我的同事已经发表了一些关于[Java内部机制的文章](http://www.cubrid.org/blog/tags/Java/)，它们已经在Twitter上变得很流行，你可以去看看。

回到GC，在学习GC之前，你应该知道一个技术名词，这个词是"stop-the-world"，无论你选择哪个算法，Stop-the-world都会发生。这意味着JVM停止应用程序，进而运行GC。当stop-the-world发生时，除了垃圾回收线程，其它所有线程都将停止运行。被中断的任务GC执行完成后恢复，GC调优往往意味着减少stop-the-world的时间。

<!-- more -->

### 分代垃圾收集

在程序中，Java没有明确地指定分配内存和删除内存的方法，一些开发人员将相关对象设置为null或者使用`System.gc()`方法来显式地删除内存。设置为null不是一个大问题，但是调用`System.gc()`方法会大幅影响系统性能，一定不要这样做。（值得庆幸的是，我还没有看到在NHN的任何开发者调用这个方法）

在Java程序里面，开发者不会显式地删除内存，垃圾收集器会找到没有必要（垃圾）对象，然后删除它们。这个垃圾回收器被创建基于以下两个假设。（称为它们为前提条件更好，而不是假设）

* 大多数对象很快变得不可达
* 只有少量年老对象引用年轻对象

这些假设被称为**弱代假设**(weak generational hypothesis)。为了发挥这一假设的优势，在HotSpot虚拟机中，物理地将内存分为两个——**年轻代(young generation)**和**年老代(old generation)**。

**年轻代**：大多数新创建的对象被分配到这里。因为大多数对象很快变得不可达，所以很多对象在年轻代中创建，然后消失。当对象从这个区域消失时，我们说一个"**minor GC**"发生了。

**年老代**：这些对象没有变得不可达，从年轻代幸存下来的对象被复制到这里。一般比年轻代更大。因为它的规模大，GC比年轻代发生的频率更低。当对象从年老代消失，我们说一个"**major GC**"(或者一个"**full GC**")发生了。

让我们来看看这个图：

![](http://7xrcq5.com1.z0.glb.clouddn.com/java-gc-1.png)

上图中的**永久代(permanent generation)**也叫做"**方法区(method area)**"，它存储class对象和字符串常量（it stores classes or interned character strings），因此这块内存区域绝对不是永久地存放从年老代存活下来的对象。GC也可能发生在这个区域，发生在这里的垃圾回收也称为major GC。

一些人可能会问：

> 如果一个年老代的对象需要引用一个年轻代的对象怎么办？

为了解决这个问题，在年老代中有一个叫做"卡表(card table)"的东西，它是一个512字节的块，每当在年老代中的一个对象引用年轻代中的对象，它记录在此表中。当对年轻代执行GC的时候，只需要对这张表进行搜索以确定是否需要进行垃圾回收，而不是检查所有年老代中所有对象的引用。这张表被"写闸(write barrier)"管理。*写闸*是一种装置，对minor GC有更快的性能。虽然这种机制会产生一些时间性能开销，但降低了整体的GC时间。

![](http://7xrcq5.com1.z0.glb.clouddn.com/java-gc-2.png)

### 年轻代组成部分

为了理解GC，我们学习一下年轻代，对象第一次创建发生在这块区域。年轻代分为3块。

* Eden区
* 2个Survivor区

总共三个区，两个Survivor区。各个区的执行顺序如下：

1. 绝大多数新创建的对象分配在Eden区
2. 在Eden发生一次GC后，存活的对象移动到其中一个Survivor区
3. 在Eden发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其它存活的对象。
4. 一旦一个Survivor已满，存活的对象移动到另外一个Survivor区。然后之前那个已满的Survivor区将置空，没有任何数据。
5. 经过重复多次这样的步骤后依旧存活的对象被移到年老代。

正如你所看到的这些步骤，一个Survivor区必须保持为空。如果两个Survivor区都有数据，或者两个都没有使用，你可将这个情况作为系统错误的一个标志。

经过多次minor GC，数据被转移到年老代的过程如下图所示：

![](http://7xrcq5.com1.z0.glb.clouddn.com/java-gc-3.png)

请注意，在HotSpot虚拟机中，使用两种技术加快内存的分配。一个被称为“**指针碰撞(bump-the-pointer)**”，另外一个被称为“**TLABs（线程本地分配缓冲）**”。

**指针碰撞**技术跟踪分配给Eden区上最新的对象。该对象将位于Eden区的顶部。如果之后有一个对象创建，只需检查Eden区是否有足够大的空间存放该对象。如果空间够用，它将被旋转在Eden区，存放在空间的顶部。因此，在创建新对象时，只需检查最后被添加的对象，看是否还有更多的内存空间允许分配。然而，如果考虑多线程环境，则是另外一种情况。为了实现多线程环境下，在Eden区线程安全的去创建保存对象，那么必须加锁，因此性能会下降。在HotSpot虚拟机中**TLABs**能够解决这一问题。它允许每个线程在Eden区有自己的一小块私有空间。因为每个一个线程只能访问自己的TLAB，所以在这个区域甚至可以使用无锁的指针碰撞技术进行内存分配。

我们已经对年轻代有了一个快速的浏览，你不需要记住我刚才提到的两种技术。即便你不知道他们，也不会怎样。但请务必记住：对象第一次被创建发生在Eden区，长期存活的对象被从Survivor区移动到年老代。

### 老年代GC

当年老代数据满时，基本上会执行一次GC。执行程序根据不同GC类型而变化，所以知道不同类型的垃圾收集器，会更容易理解垃圾回收过程。

在JDK7中，有5种垃圾收集器：

1. Serial GC
2. Parallel GC
3. Parallel Old GC (Parallel Compacting GC)
4. Concurrent Mark & Sweep GC  (or "CMS")
5. Garbage First (G1) GC

其中，**serial GC 不能用于服务端**，这个收集器类型仅应用于单核CPU桌面电脑。使用serial收集器会显著降低应用程序的性能。

现在让我们来了解每个收集器类型。

**Serial GC (-XX:+UseSerialGC)**

我们在前一段的解释了在年轻代发生的垃圾回收算法类型，在老年代的GC使用算法被称为"**标记——清除——整理**"。

1. 该算法的第一步是在年老代标记存活的对象。（标记）
2. 然后从头开始检查堆内存空间，只留下依然幸存的对象。（清除）
3. 最后一步，从头开始，顺序地填满堆内存空间，将存活的对象连续放在一起，这样堆分成两部分：一边有存放对象，一边没有对象（整理）

serial收集器应用于小内存和少量的CPU。

**Parallel GC (-XX:+UseParallelGC)**

![](http://7xrcq5.com1.z0.glb.clouddn.com/java-gc-4.png)

从这幅图中，你可以很容易地看到**Serial收集器和Parallel收集器的差异**。serial收集器只使用一个线程来处理GC，而parallel收集器使用多线程并行处理GC，因此更快。当有足够大的内存和大量芯数时，parallel收集器是有用的。它也被称淡"吞吐量优先垃圾收集器(throughput GC)"。

**Parallel Old GC(-XX:+UseParallelOldGC)**

Parallel Old收集器是自JDK5开始支持的。相比于parallel收集器，它们的唯一区别就是在年老代所执行GC的算法不同。它执行三个步骤：*标记——汇总——压缩(mark – summary – compaction)*。汇总步骤与清理的不同之处在于，其将依然幸存的对象分发到GC预先处理好的不同区域(The summary step identifies the surviving objects separately for the areas that the GC have previously performed)，算法相对清理来说略微复杂一点。

**CMS GC (-XX:+UseConcMarkSweepGC)**

![](http://7xrcq5.com1.z0.glb.clouddn.com/java-gc-5.png)

如你在上图看到的那样，CMS垃圾收集器比之前我解释的各种算法都要复杂很多。初始标记(inital mark)比较简单。这一步骤只是查找距离类加载器最近的幸存对象。所以停顿时间非常短，之后的并发标记步骤，所有被幸存对象引用的对象会被确认是否已经被追踪检查。这一步不同之处在于，在标记的过程中，其它线程依然在执行。在重新标记步骤会修正那些在并发标记步骤中，因新增或者删除对象而导致变动的那部分标记记录。最后，在并发清除步骤，垃圾收集器执行。垃圾收集器进行垃圾收集时，其它线程依旧在工作。一旦采取了这种GC类型，由于垃圾回收导致的停顿时间会极其短暂。CMS收集器也被称为低延迟垃圾收集器。它经常被用在那些对于响应时间要求十分苛刻的应用上。

当然，这种GC类型在拥有stop-the-word时间很短的优点同时，也有如下缺点：

* 它会比其它GC类型占用更多的内存和CPU
* 默认情况下不支持压缩步骤

在使用这个GC类型之前你需要慎重考虑。如果因为内存碎片过多而导致压缩任务不得不执行，那么stop-the-word的时间要比其它任何GC类型都长，你需要考虑压缩任务的发生频率以及执行时间。

**G1 GC**

最后，我们来学习一下G1类型

![](http://7xrcq5.com1.z0.glb.clouddn.com/java-gc-6.png)

如果你想要理解G1收集器，首先你要忘记你所理解的年轻代和年老代。正如你在上图所看到的，每个对象被分配到不同的网格中，随后执行垃圾回收。当一个区域填满之后，对象被转移到另一个区域，并再执行一次垃圾回收。在这种垃圾回收算法中，不再有从年轻代移动到年老代的三部曲。这个类型的垃圾收集算法是为替代CMS收集器而被创建的，因为CMS收集器在长时间持续运行时会产生很多问题。

G1的最大好处是它的**性能**，它比我们在上面讨论过的任何一种GC都要快。但是在JDK6中，他还只是一个早期试用版本。在JDK7之后才由官方正式发布。就我个人看来，NHN在将JDK7正式投入商用之前需要很长的一段测试期（至少一年）。因此你可能需要再等一段时间。并且，我也听过几次使用了JDK6中的G1而导致Java虚拟机宕机的事件。请耐心的等待它更稳定吧。

下一次我将讨论**GC优化**相关的问题，但是在此之前我要先明确一件事件。假如应用中创建的所有对象的大小和类型都是统一的，在我们公司，这种情况下使用的WAS的GC参数可以是相同的。但是WAS所创建对象的大小和生命周期根据服务以及硬件的不同而不同。换句话说，不能因为某个应用使用的GC参数是"A"，就说明同样的参数也能给其它服务带来最佳的效果。而是要因地制宜，有的放矢。我们需要找到适合每个WAS线程的最佳参数，并且持续的监控和优化每个设备上的WAS实例。这并不是我的一家之谈，而是负责Oracle Java虚拟机研发的工程师在JavaOne 2010上已经讨论过的。

本文中我们简略地介绍了Java的垃圾回收机制，请继续关注我们的后续文章，我们会讨论**如何监控Java GC状态以及GC调优**。

另外我特别推荐一本2011年12月发布的"*Java Performance*"([Amazon](http://amzn.com/0137142528)，如果公司提供一个账户，它可以使用Safari在线阅读)，还有在Oracle官网发布的白皮书"*Memory Management in the Java HotSpotTM Virtual Machine,*"（这本书与"*Java Performance Tuning*"不是同一本）





